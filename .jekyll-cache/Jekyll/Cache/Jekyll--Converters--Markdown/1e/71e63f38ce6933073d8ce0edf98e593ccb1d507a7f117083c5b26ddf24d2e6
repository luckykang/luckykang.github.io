I" <h3 id="1-pythonä¸­åŠ è½½openvino">1. pythonä¸­åŠ è½½openvino</h3>
<p>æŠŠopenvinoå®‰è£…ç›®å½• C:\Intel\openvino\python\python3.6 ä¸‹çš„ openvinoæ–‡ä»¶å¤¹ <br />
ç²˜è´´åˆ°pythonå®‰è£…ç›®å½•ä¸‹   C:\Python36\Lib\site-packages</p>

<h3 id="2-æ‰¾ä»£ç demo">2. æ‰¾ä»£ç demo</h3>
<p>C:\Intel\openvino_2019.1.087\deployment_tools\inference_engine\samples\python_samples\object_detection_demo_ssd_asyncç›®å½•ä¸‹
object_detection_demo_ssd_async.pyæ–‡ä»¶ä»£ç æ‹¿æ¥ä½¿ç”¨</p>

<h3 id="3-ç¼–è¯‘">3. ç¼–è¯‘</h3>
<p>C:\Intel\openvino\deployment_tools\inference_engine\samples è·¯å¾„ä¸‹ æ‰§è¡Œ</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>build_samples_msvc2017.bat
</code></pre></div></div>

<p>æ‰§è¡Œå®Œååœ¨C:\Users\kang\Documents\Intel\OpenVINO ç›®å½•å¯ä»¥çœ‹åˆ°ç”Ÿæˆçš„inference_engine_samples_build_2017 æ–‡ä»¶ç›®å½•</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cpu_extension = "C:\Users\kang\Documents\Intel\OpenVINO\inference_engine_samples_build_2017\intel64\Release\cpu_extension.dll"
</code></pre></div></div>

<h3 id="4-ä¸‹è½½æ¨¡å‹-road-segmentation-adas-0001-è®°å½•xmlåœ°å€">4. ä¸‹è½½æ¨¡å‹ road-segmentation-adas-0001 è®°å½•xmlåœ°å€</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>model_xml = ""   
model_bin = ""
</code></pre></div></div>

<h3 id="5-å¡«å†™å‚æ•°">5. å¡«å†™å‚æ•°</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>plugin_dir = ""     
cap = cv2.VideoCapture("")
</code></pre></div></div>

<h3 id="é™„å½•ä»£ç ">é™„å½•ä»£ç ï¼š</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import sys
import cv2
import numpy as np
import time
import logging as log
from openvino.inference_engine import IENetwork,IEPlugin
model_xml  = "C:/Users/kang/Downloads/open_model_zoo-2019/model_downloader/Transportation/segmentation/curbs/dldt/road-segmentation-adas-0001.xml"
model_bin = "C:/Users/kang/Downloads/open_model_zoo-2019/model_downloader/Transportation/segmentation/curbs/dldt/road-segmentation-adas-0001.bin"
plugin_dir = "C:/Intel/openvino/deployment_tools/inference_engine/bin/intel64/Release"
cpu_extension = "C:/Users/kang/Documents/Intel/OpenVINO/inference_engine_samples_build_2017/intel64/Release/cpu_extension.dll"


def read_segmentation_demo():
    log.basicConfig(format="[ %(levelname)s ] %(message)s",
                    level=log.INFO,
                    stream=sys.stdout)
    # Plugin initialization for specified device and load extensions library if specified
    log.info("Initializing plugin for {} device...".format("CPU"))
    plugin = IEPlugin(device="CPU", plugin_dirs=plugin_dir)
    plugin.add_cpu_extension(cpu_extension)
    # Read IR
    log.info("Reading IR...")
    net = IENetwork(model=model_xml, weights=model_bin)

    if plugin.device == "CPU":
        supported_layers = plugin.get_supported_layers(net)
        not_supported_layers = [
            l for l in net.layers.keys() if l not in supported_layers
    ]
        if len(not_supported_layers) != 0:
            log.error(
                "Following layers are not supported by the plugin for specified device {}:\n {}"
                .format(plugin.device, ', '.join(not_supported_layers)))
            log.error(
                "Please try to specify cpu extensions library path in demo's command line parameters using -l "
                "or --cpu_extension command line argument")
            sys.exit(1)
        assert len(
            net.inputs.keys()) == 1, "Demo supports only single input topologies"
        assert len(net.outputs) == 1, "Demo supports only single output topologies"
        input_blob = next(iter(net.inputs))
        out_blob = next(iter(net.outputs))
        log.info("Loading IR to the plugin...")
        exec_net = plugin.load(network=net, num_requests=2)
        # Read and pre-process input image
        n, c, h, w = net.inputs[input_blob].shape
        del net
        cap = cv2.VideoCapture("C:/Users/kang/Downloads/opencv_tutorial/data/images/road_line.mp4")

        cur_request_id = 0
        next_request_id = 1

        log.info("Starting inference in async mode...")
        log.info("To switch between sync and async modes press Tab button")
        log.info("To stop the demo execution press Esc button")
        is_async_mode = True
        render_time = 0
        ret, frame = cap.read()

        print(
            "To close the application, press 'CTRL+C' or any key with focus on the output window"
        )
        while cap.isOpened():
            if is_async_mode:
                ret, next_frame = cap.read()
            else:
                ret, frame = cap.read()
            if not ret:
                break
            initial_w = cap.get(3)
            initial_h = cap.get(4)
            # å¼€å¯åŒæ­¥æˆ–è€…å¼‚æ­¥æ‰§è¡Œæ¨¡å¼
            inf_start = time.time()
            if is_async_mode:
                in_frame = cv2.resize(next_frame, (w, h))
                in_frame = in_frame.transpose(
                    (2, 0, 1))  # Change data layout from HWC to CHW
                in_frame = in_frame.reshape((n, c, h, w))
                exec_net.start_async(request_id=next_request_id,
                             inputs={input_blob: in_frame})
            else:
                in_frame = cv2.resize(frame, (w, h))
                in_frame = in_frame.transpose(
                    (2, 0, 1))  # Change data layout from HWC to CHW
                in_frame = in_frame.reshape((n, c, h, w))
                exec_net.start_async(request_id=cur_request_id,
                             inputs={input_blob: in_frame})
            if exec_net.requests[cur_request_id].wait(-1) == 0:
                inf_end = time.time()
                det_time = inf_end - inf_start

                # è·å–ç½‘ç»œè¾“å‡º
                res = exec_net.requests[cur_request_id].outputs[out_blob]
                # è§£æé“è·¯åˆ†å‰²ç»“æœ
                res = np.squeeze(res, 0)
                res = res.transpose(1, 2, 0)  #HWCæ ¼å¼
                res = np.argmax(res, 2)
                hh, ww = res.shape
                mask = np.zeros((hh, ww, 3), dtype=np.uint8)
                mask[np.where(res &gt; 0)] = (0, 255, 255)
                mask[np.where(res &gt; 1)] = (255, 0, 255)

                # æ˜¾ç¤ºmask
                cv2.imshow("mask",mask)

                # Draw performance stats
                inf_time_message = "Inference time: N\A for async mode" if is_async_mode else \
                    "Inference time: {:.3f} ms".format(det_time * 1000)
                render_time_message = "OpenCV rendering time: {:.3f} ms".format(
                    render_time * 1000)
                async_mode_message = "Async mode is on. Processing request {}".format(cur_request_id) if is_async_mode else \
                    "Async mode is off. Processing request {}".format(cur_request_id)

                cv2.putText(frame, inf_time_message, (15, 15),
                            cv2.FONT_HERSHEY_COMPLEX, 0.5, (200, 10, 10), 1)
                cv2.putText(frame, render_time_message, (15, 30),
                            cv2.FONT_HERSHEY_COMPLEX, 0.5, (10, 10, 200), 1)
                cv2.putText(frame, async_mode_message, (10, int(initial_h - 20)),
                            cv2.FONT_HERSHEY_COMPLEX, 0.5, (10, 10, 200), 1)

            render_start = time.time()
            cv2.imshow("segmentation Results", frame)
            render_end = time.time()
            render_time = render_end - render_start

            if is_async_mode:
                cur_request_id, next_request_id = next_request_id, cur_request_id
                frame = next_frame

            key = cv2.waitKey(1)
            if key == 27:
                break
        cv2.destroyAllWindows()


if __name__ == '__main__':
    sys.exit(read_segmentation_demo() or 0)
</code></pre></div></div>

<p>è½¬è½½è¯·æ³¨æ˜ï¼š<a href="https://luckykang.github.io">åº·ç‘¶æ˜çš„åšå®¢</a> Â» <a href="http://baixin.io/2020/06/">ç‚¹å‡»é˜…è¯»åŸæ–‡</a></p>

:ET